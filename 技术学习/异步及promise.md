# 异步编程及 promise 学习心得

​	异步设计到现在执行模块和将来执行模块之间的关系，当然这是核心。我将从什么是异步、异步机制、回调函数、promise 以及它的设计基础，这几个方面介绍异步编程。JavaScript 从前端到 node以及其它的环境，异步变得越来越重要，也很难学（同步顺序执行往往是我们最喜欢的方式）。

## 什么是异步

​	通常来说程序执行是通过分块来组织的，常用的有 module ，或者一个函数。有些块（函数）是现在执行的，有的是将来执行（充满不确定性，并不是现在的块执行完后就立即执行例如 Ajax ），现在无法完成的任务交给未来某个时刻去完成。 

​	

```javascript
var data  = ajax(/*url*/);

console.log(data);//undefined

```

显然理想的把异步阻塞执行，然而它并不会这样做。简单补充一下 Ajax ，它是一个异步函数 其中主要的一个对象是 `XMLHttpRequest `大多数时候都是异步执行的，当然它可以同步执行（我劝你最好不要这样做，同步执行时它会锁定浏览器 `UI` 所有的按钮，菜单、滚动条、点击事件等都不能产生交互,这是很糟糕的用户体验）。

​	说点题外话，异步控制台。`console.*`  开发中经常使用来做输出调试的个函数族，我说它也是异步的你可能不信，但是它的机制确实是这样的。我们呢很喜欢用它来打印快照（对象快照）

​	

```javascript
var count = 0;

console.log(count);

count++;

```

​	通常我们认为console 了 就得打印出：0，然后再自加1，浏览器实际上到了console这时 会开一个异步 i/o 到后台，等回台执行时 可能 count++ 已经执行掉了。当然这通常使用都不会出问题，因为这是游离不定的没法预测。出现异常时最好结合debugger ，或者`JSON `来将数据（对象转换成字符串）快照下来。至少到这个时候你该意识到这是i/o 异步化造成的。

## 事件循环

​	先来说说 JavaScript引擎 ，一句话来说就是一个按需执行JavaScript代码块的一个环境。事件循环是环境（此时的化境并不是JavaScript引擎提供的环境，而是代码运行的工作化境比如：web浏览器，node服务器）提供来处理程序中多个块的执行，且执行每块时调用JavaScript引擎的一种机制。实际上提供一个事件队列（这儿有个坑，先挖一下），然后死循环这个队列。每次从头部取一个任务执行大概这样简化模拟一下：

​	

```javascript

var EventList;
while(true){
    if(EventList.length>0){
        var event = EventList.shift();
        try{
            event()
        }catch（err）{
            reportErr(err);
            //把错误抛出来
        }
    }
    
}

```

每次取出的 event 叫做一个 tick ，这样借助Ajax 来讲一下。

```javascript
ajax(url,callback);
```

环境执行到这个块时，发现是个异步 块。JavaScript引擎就会停下来转去执行其它的块，然后环境进行侦听当数据请求回来以后把 callback 这个回调函数插入事件队列中排队。说到这儿顺带提一句，大家都很喜欢使用来做定时器的 `setTimeout`  。确实它原本就是一个定时器，但是是给环境定时的。告诉环境多少时间后把回调函数插入事件队列。` setTimeout(cd，1000)`  一秒后把回调函数 `cd` 给排队起来。这时如果事件队列里面还有子项（假如有存在耗时比较长的任务，就会很明显）换句话说不能插进去就立即执行那就对于你来说是超时的（好好想想你想用来干嘛的）。所以它只能保证多少时间前不能执行！！

## 认知的误区（并行与异步、并发）

​	异步是关于现在和将来的存在一个时间空隙，并行是关于同时发生的事。并行通常借助进程和线程来实现计算，可顺序执行也可能并行执行。在一个进程中的线程可以共享资源。与之相对的是，事件循环把任务分为一个一个的执行更细腻的JavaScript引擎也是单线程的。因此我们并不去思考并行带来的很多不确定性（语句顺序级）。竞态会在 generator 中详细解释（挖个坑，肯定会做的）

​	并发，在同一段时间内两个任务同时执行。// 不想做这儿的例举分析，交互（处理竞态）、非交互、协作



##  任务队列

​	这很刺激吧！记得要和事件循环区分开。前面我们说到了事件循环的每一次叫一个 tick，而这个任务队列就是追加在 tick 后面的一个任务列表（通常是异步任务）当然promise 就是基于这样的原理。因此当下一个 tick 执行之前，前一个的任务队列上的任务都已经执行完毕。因此说promise 来做定时器更精准些。有的参考资料上把事件循环和任务队列称呼为宏任务和微任务（有道理）。

//画图分析关系，



## 最基础的异步模式——回调函数

​	在异步编程中，回调是最基础的模式。对于我们初级程序员来说很享受用这种方式来异步编程。但是它存在一些问题（heal）， `ES6`  引入的 `promise `  更高级和复杂的处理异步。但是其抽象机制，稍微有一点儿麻烦（第一次我是很头疼的）假如不了解其真的核心，就很难把握实现的细节（挖个坑，我会介绍到它）。



### 嵌套回调和链式回调

​	太深层的嵌套会带来代码 bug 追踪困难可读性很差（看起来很费劲）不停的切换上下文，有种称呼叫回调地狱。其实信任问题才是更地狱！！

​	

```javascript

listen('click',function handle(){
    setTimeout(function request(){
        ajax(url,function response(data){
            if(data== 'xxx'){
                handle();
            }else{
                request();
            }
        },function (){})
    },100)
})

// 此例 来源 你不知道的JavaScript,

```

这种嵌套还是比较简单了，更疯狂的回调。https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553356279281&di=9556975f4c83f766b2fc475d5ef313d6&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F77104c85628acda22441c8a4cb6ca394.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100





### 信任问题 

​	继续使用 `ajax` （也可以使用 `axios` ,`fetch-jsonp`  等等第三方库）来说事，通常这些第三方的库函数执行需要传入回调函数。我们将自己封装的函数执行控制交给第三方（对于你而言这是一个黑盒，当然你也可以查看源码），因此什么时候执行，执行多少次都是不可见的。这通常被称为控制反转。

有这么一些问题值得思考：

 * 调用过早/或过晚
 * 调用次数过多/过少（不执行）
 * 吞掉异常和错误
 * 执行时没有传入环境或者参数

你有办法吗？朋友你一点办法都没有。因此回调最大的问题就是控制反转，完全导致信任链的断裂。

补充一点：Error-first 模式。

## promise 

​	’你能做的我会，你不会的我还是会‘。任何强大的技术都不止于技术本身，promise一样当结合 generator （再挖个坑，有空我会继续写篇关于这方面的心得）时，异常强大。根据问题现在我们需要一个解决 反转控制问题，缺乏顺序性的范式。第三方不再去执行我的回调（因为我们想控制一切），第三方库只需要给我一个了解其任务何时结束的超能力（promise 决议对象）。也就是说，你让我知道你什么时候做完我需要你做的工作，我自己决定我接下来该怎么干。这不是很好么！！现在很多平台新增的API 都是基于Promise 来构建的，赶快跟宏哥一起学吧！

### 什么是promise 

​	先来说一个故事，有一天罗学长心血来潮。打电话给学姐A：“我想去跑步，喝奶茶也行，有空吗？宝贝”，这个学姐呢很地道不管能不能去都会回消息。学姐A：“好的，晚点打给你给你答复”。这时罗学长就拿到一个promise（承诺），高兴的开始写代码。晚上十点，学姐A发来短信：“今晚有空，你来接我吧！”，当然也可能收到“今晚不行，我要学习”。好吧！看出来了，一个resolve，一个reject 。对吧，至少这就是执行情况了（我们称之为决议，总会有的）。因此，带来新的问题，未来的值是什么（有可能是上面的短信），决议后执行的事件（罗学长当场气死也算）。

​	///#### 发布前删掉彩蛋

####  promise 值

​	promise值有三个状态，pending （未决议），resolve（完成），reject （拒绝）。pending  =》 reject /resolve 。一旦决议值就会一直保持，不可修改。通常调用函数`Promise.prototype.*` 函数都会返回一个决议后的promise值。注意：reject 值可能是显示生成的也可能是隐式生成的（事件函数出现异常，出错等）。

#### promise事件

​	现在我们来实现一下如何注册事件（成功或者失败的处理事件）

```javascript
function MyAjax(url){
    //做请求
    var data = ajax(url)
    return new Promise(function (resolve,reject){
        //根据决议来回调
        if (data){
            resolve(data);
        }else{
            reject (new Error)
        }
    });
}

function foo(promiseObj){
    promiseObj && promiseObj.then(function (data){
        console.log(data);
    },
                                  function (err){
        console.log(err);
    })
}

var p = MyAjax(/*url*/);
foo(p);

```

还有另一种常用事件注册：`.then ` `.catch`



